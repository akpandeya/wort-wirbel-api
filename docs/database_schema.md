# Database Schema Documentation

## Overview

The Wort-Wirbel API uses a PostgreSQL database to store vocabulary/grammar words. The database follows a simple relational schema designed for efficient storage and retrieval of word data.

## Schema Design

### Words Table

The `words` table is the core table for storing vocabulary words and their metadata.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | INTEGER | PRIMARY KEY, AUTO INCREMENT | Unique identifier for each word |
| `word` | STRING | NOT NULL, INDEX | The actual word text |
| `definition` | STRING | NOT NULL | Definition or meaning of the word |
| `part_of_speech` | ENUM | NOT NULL | Grammatical part of speech |
| `difficulty` | ENUM | NOT NULL | Learning difficulty level |
| `updated_at` | DATETIME | NOT NULL, AUTO UPDATE | Last modification timestamp |

### Enumerations

#### Part of Speech
- `noun`
- `verb`
- `adjective`
- `adverb`
- `pronoun`
- `preposition`
- `conjunction`
- `interjection`
- `article`
- `other`

#### Difficulty Level
- `beginner`
- `intermediate`
- `advanced`

## Database Configuration

The database connection is configured via environment variables:

| Environment Variable | Default | Description |
|---------------------|---------|-------------|
| `DB_HOST` | `localhost` | Database host |
| `DB_PORT` | `5432` | Database port |
| `DB_NAME` | `wort_wirbel` | Database name |
| `DB_USER` | `postgres` | Database username |
| `DB_PASSWORD` | `postgres` | Database password |

## Migrations

Database migrations are managed using Alembic. To create and apply migrations:

```bash
# Create a new migration
poetry run alembic revision --autogenerate -m "Description of changes"

# Apply migrations
poetry run alembic upgrade head

# Rollback migration
poetry run alembic downgrade -1
```

## Sample SQL

### Create Table (Generated by Migration)

```sql
CREATE TABLE words (
    id SERIAL PRIMARY KEY,
    word VARCHAR NOT NULL,
    definition VARCHAR NOT NULL,
    part_of_speech ENUM('noun', 'verb', 'adjective', 'adverb', 'pronoun', 
                        'preposition', 'conjunction', 'interjection', 'article', 'other') NOT NULL,
    difficulty ENUM('beginner', 'intermediate', 'advanced') NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE INDEX ix_words_word ON words(word);
CREATE INDEX ix_words_id ON words(id);
```

### Sample Data

```sql
INSERT INTO words (word, definition, part_of_speech, difficulty) VALUES
('apple', 'A round fruit with red or green skin', 'noun', 'beginner'),
('run', 'To move quickly on foot', 'verb', 'beginner'),
('beautiful', 'Pleasing to look at', 'adjective', 'intermediate');
```

## Repository Pattern

The database access follows the Repository pattern with:

- **Domain Models**: Pydantic models defining the business domain (`app/domain/models.py`)
- **SQLAlchemy Models**: Database table definitions (`app/infrastructure/database/models.py`)  
- **Repository Interface**: Abstract interface for data access (`app/infrastructure/repositories/word_repository.py`)
- **Repository Implementation**: Concrete SQLAlchemy implementation

This pattern provides:
- Clean separation between domain logic and data access
- Easy testing with mock repositories
- Database implementation flexibility
- Type safety with Python typing