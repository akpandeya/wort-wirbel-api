# Database Schema Documentation

## Overview

The Wort-Wirbel API uses a PostgreSQL database to store comprehensive vocabulary/grammar words with multi-language support, learning progress tracking, and rich metadata. The database follows a comprehensive schema designed for efficient storage and retrieval of word data according to the specification in issue #33.

## Schema Design

### Words Table

The `words` table is the core table for storing vocabulary words and their comprehensive metadata.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | STRING | PRIMARY KEY | Unique identifier in format `{lang}:{lemma}:{variant_id}` |
| `lemma` | STRING | NOT NULL, INDEX | Canonical form of the word |
| `lang` | STRING | NOT NULL, INDEX | Language code (e.g., "de", "en") |
| `pos` | ENUM | NOT NULL | Grammatical part of speech |
| `pos_specific` | STRING | NULLABLE | Language-specific part of speech |
| `defs` | JSON | NOT NULL | Array of definitions |
| `synonyms` | JSON | NULLABLE | Array of synonyms |
| `examples` | JSON | NULLABLE | Array of usage examples with translations |
| `freq_rank` | INTEGER | NULLABLE | Frequency ranking |
| `cefr` | ENUM | NULLABLE | Common European Framework level (A1-C2) |
| `gender` | ENUM | NULLABLE | Grammatical gender |
| `plural` | STRING | NULLABLE | Plural form |
| `audio` | TEXT | NULLABLE | Audio URL |
| `src` | STRING | NULLABLE | Source identifier |
| `success_streak` | INTEGER | DEFAULT 0 | Number of consecutive correct answers |
| `last_reviewed_at` | DATETIME | NULLABLE | Last review timestamp |
| `next_review_at` | DATETIME | NULLABLE | Next scheduled review timestamp |
| `created_at` | DATETIME | NOT NULL, AUTO | Creation timestamp |
| `updated_at` | DATETIME | NOT NULL, AUTO UPDATE | Last modification timestamp |

### Enumerations

#### Part of Speech
- `noun`
- `verb` 
- `adjective`
- `adverb`
- `pronoun`
- `preposition`
- `conjunction`
- `interjection`
- `article`
- `determiner`
- `particle`
- `other`

#### CEFR Level (Common European Framework)
- `A1` - Beginner
- `A2` - Elementary  
- `B1` - Intermediate
- `B2` - Upper Intermediate
- `C1` - Advanced
- `C2` - Proficient

#### Gender
- `masculine`
- `feminine` 
- `neuter`

## Database Configuration

The database connection is configured via environment variables:

| Environment Variable | Default | Description |
|---------------------|---------|-------------|
| `DB_HOST` | `localhost` | Database host |
| `DB_PORT` | `5432` | Database port |
| `DB_NAME` | `wort_wirbel` | Database name |
| `DB_USER` | `postgres` | Database username |
| `DB_PASSWORD` | `postgres` | Database password |

## Migrations

Database migrations are managed using Alembic and stored in the `migrations/` folder. To create and apply migrations:

```bash
# Create a new migration
poetry run alembic revision --autogenerate -m "Description of changes"

# Apply migrations
poetry run alembic upgrade head

# Rollback migration
poetry run alembic downgrade -1
```

## Sample SQL

### Create Table (Generated by Migration)

```sql
CREATE TABLE words (
    id VARCHAR PRIMARY KEY,
    lemma VARCHAR NOT NULL,
    lang VARCHAR NOT NULL,
    pos ENUM('NOUN', 'VERB', 'ADJECTIVE', 'ADVERB', 'PRONOUN', 'PREPOSITION', 
             'CONJUNCTION', 'INTERJECTION', 'ARTICLE', 'DETERMINER', 'PARTICLE', 'OTHER') NOT NULL,
    pos_specific VARCHAR,
    defs JSON NOT NULL,
    synonyms JSON,
    examples JSON,
    freq_rank INTEGER,
    cefr ENUM('A1', 'A2', 'B1', 'B2', 'C1', 'C2'),
    gender ENUM('MASCULINE', 'FEMININE', 'NEUTER'),
    plural VARCHAR,
    audio TEXT,
    src VARCHAR,
    success_streak INTEGER DEFAULT 0,
    last_reviewed_at TIMESTAMP,
    next_review_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP DEFAULT NOW() NOT NULL
);

CREATE INDEX ix_words_id ON words(id);
CREATE INDEX ix_words_lemma ON words(lemma);
CREATE INDEX ix_words_lang ON words(lang);
```

### Sample Data

```sql
INSERT INTO words (id, lemma, lang, pos, defs, cefr, created_at, updated_at) VALUES
('de:hallo:1', 'Hallo', 'de', 'INTERJECTION', '["hello", "hi"]', 'A1', NOW(), NOW()),
('en:house:1', 'house', 'en', 'NOUN', '["a building for human habitation", "dwelling"]', 'A1', NOW(), NOW()),
('de:haus:1', 'Haus', 'de', 'NOUN', '["house", "building"]', 'A1', NOW(), NOW());
```

## Repository Pattern

The database access follows the Repository pattern with:

- **Domain Models**: Pydantic models defining the business domain (`app/domain/models.py`)
- **SQLAlchemy Models**: Database table definitions (`app/infrastructure/database/models.py`)  
- **Repository Interface**: Abstract interface for data access (`app/infrastructure/repositories/word_repository.py`)
- **Repository Implementation**: Concrete SQLAlchemy implementation

This pattern provides:
- Clean separation between domain logic and data access
- Easy testing with mock repositories
- Database implementation flexibility
- Type safety with Python typing

## JSON Field Structure

### Examples Field
```json
[
  {"text": "Hallo Welt!", "tr": "Hello world!"},
  {"text": "Hallo, wie geht's?", "tr": "Hello, how are you?"}
]
```

### Definitions Field
```json
["hello", "hi", "greeting"]
```

### Synonyms Field  
```json
["hi", "guten Tag", "servus"]
```

## Learning Progress Integration

The schema includes built-in support for spaced repetition learning:

- **success_streak**: Tracks consecutive correct answers
- **last_reviewed_at**: When the word was last studied
- **next_review_at**: When the word should be reviewed next

This enables implementation of spaced repetition algorithms directly in the database layer.